package rs.igapp.aurora.server.controller;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import rs.igapp.aurora.api.dto.request.AlertRequest;
import rs.igapp.aurora.api.dto.response.AlertResponse;
import rs.igapp.aurora.server.service.AlertService;

import java.time.LocalDateTime;
import java.util.List;

/**
 * 
 * ENDPOINTS:
 * - GET    /api/alerts/status/{statusId}     -> Filter alerts by status
 * - GET    /api/alerts/severity/{severityId} -> Filter alerts by severity
 * - GET    /api/alerts/rule/{ruleId}         -> Get all alerts for specific rule
 * - GET    /api/alerts/range                 -> Get alerts in time range
 * - GET    /api/alerts/analyst/{username}    -> Get alerts assigned to analyst
 * - PATCH  /api/alerts/{id}/assign           -> Assign alert to analyst
 * - PATCH  /api/alerts/{id}/notes            -> Add investigation notes
 * - PATCH  /api/alerts/{id}/resolve          -> Mark alert as resolved
 * - PATCH  /api/alerts/{id}/false-positive   -> Mark as false positive
 * 
 * NASLEDJENE CRUD OPERACIJE:
 * - POST   /api/alerts      -> Create alert (typically done by DetectionEngine)
 * - GET    /api/alerts/{id} -> Get single alert
 * - GET    /api/alerts      -> Get paginated list of alerts
 * - PUT    /api/alerts/{id} -> Update alert
 * - DELETE /api/alerts/{id} -> Delete alert (soft delete)
 */
@RestController
@RequestMapping("/api/alerts")
public class AlertController extends CrudController<AlertRequest, AlertResponse, Long> {

    private final AlertService alertService;

    public AlertController(AlertService alertService) {
        super(alertService);
        this.alertService = alertService;
    }

    // ==================== FILTERING ENDPOINTS ====================

    //FILTER BY STATUS - Get alerts by lifecycle status
     
    @GetMapping("/status/{statusId}")
    public ResponseEntity<Page<AlertResponse>> getByStatus(
            @PathVariable Long statusId,
            Pageable pageable) {
        Page<AlertResponse> alerts = alertService.getByStatus(statusId, pageable);
        return ResponseEntity.ok(alerts);
    }

    // FILTER BY SEVERITY - Get alerts by severity level
    @GetMapping("/severity/{severityId}")
    public ResponseEntity<Page<AlertResponse>> getBySeverity(
            @PathVariable Long severityId,
            Pageable pageable) {
        Page<AlertResponse> alerts = alertService.getBySeverity(severityId, pageable);
        return ResponseEntity.ok(alerts);
    }

    // FILTER BY RULE - Get all alerts generated by a specific rule
     
    @GetMapping("/rule/{ruleId}")
    public ResponseEntity<Page<AlertResponse>> getByRule(
            @PathVariable Long ruleId,
            Pageable pageable) {
        Page<AlertResponse> alerts = alertService.getByRule(ruleId, pageable);
        return ResponseEntity.ok(alerts);
    }

    // FILTER BY TIME RANGE - Get alerts created within a time window
   
    @GetMapping("/range")
    public ResponseEntity<List<AlertResponse>> getByTimeRange(
            @RequestParam LocalDateTime start,
            @RequestParam LocalDateTime end) {
        List<AlertResponse> alerts = alertService.getByTimeRange(start, end);
        return ResponseEntity.ok(alerts);
    }

    // FILTER BY ANALYST - Get all open alerts assigned to specific analyst
    @GetMapping("/analyst/{username}")
    public ResponseEntity<List<AlertResponse>> getOpenAlertsByAnalyst(
            @PathVariable String username,
            @RequestParam Long resolvedStatusId) {
        List<AlertResponse> alerts = alertService.getOpenAlertsByAnalyst(username, resolvedStatusId);
        return ResponseEntity.ok(alerts);
    }

    // ==================== LIFECYCLE MANAGEMENT ENDPOINTS ====================

    // ASSIGN - Assign alert to analyst for investigation

    @PatchMapping("/{id}/assign")
    public ResponseEntity<AlertResponse> assign(
            @PathVariable Long id,
            @RequestParam String analyst,
            @RequestParam Long investigatingStatusId) {
        AlertResponse updated = alertService.assignToAnalyst(id, analyst, investigatingStatusId);
        if (updated == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(updated);
    }

    // ADD NOTES - Add investigation notes to an alert

    @PatchMapping("/{id}/notes")
    public ResponseEntity<AlertResponse> addNotes(
            @PathVariable Long id,
            @RequestBody String notes) {
        AlertResponse updated = alertService.addInvestigationNotes(id, notes);
        if (updated == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(updated);
    }

    // RESOLVE - Mark alert as resolved (investigation complete)
     
    @PatchMapping("/{id}/resolve")
    public ResponseEntity<AlertResponse> resolve(
            @PathVariable Long id,
            @RequestParam Long resolvedStatusId) {
        AlertResponse updated = alertService.resolveAlert(id, resolvedStatusId);
        if (updated == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(updated);
    }

    // MARK FALSE POSITIVE - Mark alert as false positive (incorrect detection)
    
    @PatchMapping("/{id}/false-positive")
    public ResponseEntity<AlertResponse> markAsFalsePositive(
            @PathVariable Long id,
            @RequestParam Long falsePositiveStatusId) {
        AlertResponse updated = alertService.markAsFalsePositive(id, falsePositiveStatusId);
        if (updated == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(updated);
    }

    // ==================== STATISTICS ENDPOINT ====================

    // COUNT BY STATUS - Get count of alerts in each status
     
    @GetMapping("/count/status/{statusId}")
    public ResponseEntity<Long> countByStatus(@PathVariable Long statusId) {
        long count = alertService.countByStatus(statusId);
        return ResponseEntity.ok(count);
    }
}
